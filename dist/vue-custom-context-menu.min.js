/* Matthew Mamonov aka smellyshovel <g.smellyshovel@gmail.com> (https://github.com/smellyshovel/vue-custom-context-menu) Â© 2018 */(function(a,b){"object"==typeof exports&&"undefined"!=typeof module?module.exports=b():"function"==typeof define&&define.amd?define(b):(a=a||self,a.VCCM=b())})(this,function(){'use strict';function a(b){return a="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(a){return typeof a}:function(a){return a&&"function"==typeof Symbol&&a.constructor===Symbol&&a!==Symbol.prototype?"symbol":typeof a},a(b)}function b(b,c,d){var f="[v-context-menu=\"".concat(c.expression.replace(/\"/,"'"),"\"]");if(null===c.value){if(d.componentInstance&&"context-menu-item"===d.componentInstance.$options._componentTag)e.set(d.elm,{listener:null,cm:null}),d.componentInstance.calls=null;else{var g=function(a){a.stopPropagation(),a.altKey||a.preventDefault()};e.set(b,{listener:g,cm:null}),b.addEventListener("contextmenu",g)}return null}if("string"==typeof c.value){var h=d.context.$refs[c.value];if(h){if(!(h instanceof HTMLElement)){if("context-menu"!==h.$options._componentTag&&(h=h.$refs["wrapped-context-menu"],!h||h instanceof HTMLElement||"context-menu"!==h.$options._componentTag))throw new Error("".concat(f," | Couldn't find the 'ContextMenu' component with the reference 'wrapped-context-menu' inside the '").concat(c.value,"' wrapper-component"));if(d.componentInstance&&"context-menu-item"===d.componentInstance.$options._componentTag)e.set(d.elm,{listener:null,cm:h}),d.componentInstance.calls=h;else{var i=function(a){a.stopPropagation(),a.altKey||(a.preventDefault(),h.immediateOpen(a))};e.set(b,{listener:i,cm:h}),b.addEventListener("contextmenu",i)}return h}throw new Error("".concat(f," | The 'v-context-menu' directive must point to either the 'ContextMenu' component or a 'ContextMenu' wrapper-component, but it points to a '").concat(h.tagName,"' HTML element"))}else throw new Error("".concat(f," | Couldn't find a context menu by the reference '").concat(c.value,"'"))}else throw new TypeError("".concat(f," | The 'v-context-menu' directive only accepts 'null' and 'string' values, but '").concat(a(c.value),"' is provided"))}function c(a){var b=e.get(a),c=b.listener,d=b.cm;return c&&a.removeEventListener("contextmenu",c),e["delete"](a),d}function d(a,b){var c=i?b.media||"default":a,d=k[c]||(k[c]={ids:new Set,styles:[]});if(!d.ids.has(a)){d.ids.add(a);var e=b.source;if(b.map&&(e+="\n/*# sourceURL="+b.map.sources[0]+" */",e+="\n/*# sourceMappingURL=data:application/json;base64,"+btoa(unescape(encodeURIComponent(JSON.stringify(b.map))))+" */"),d.element||(d.element=document.createElement("style"),d.element.type="text/css",b.media&&d.element.setAttribute("media",b.media),j.appendChild(d.element)),"styleSheet"in d.element)d.styles.push(e),d.element.styleSheet.cssText=d.styles.filter(Boolean).join("\n");else{var f=d.ids.size-1,g=document.createTextNode(e),h=d.element.childNodes;h[f]&&d.element.removeChild(h[f]),h.length?d.element.insertBefore(g,h[f]):d.element.appendChild(g)}}}var e=new Map,f={bind:function(a,c,d){b(a,c,d)},update:function(a,d,e){if(d.oldValue!==d.value){var f=c(a),g=b(a,d,e);f&&f.show&&f.event.target===a&&(f.immediateClose(),g&&g.immediateOpen(f.event,f.caller,f.parent))}},unbind:function(a){var b=c(a);b&&b.show&&b.event.target===a&&b.immediateClose()}},g={props:{isRoot:{type:Boolean,required:!0},zIndex:{type:Number,required:!0},penetrable:{type:Boolean,required:!0}},methods:{close:function(a){var b=this;3===a.which&&a.altKey||(this.penetrable?this.$emit("close"):(a.stopPropagation(),setTimeout(function(){b.$emit("close")},0)))}}},h=function(a,b,c,d,e,f,g,h,i,j){"boolean"!=typeof g&&(i=h,h=g,g=!1);var k="function"==typeof c?c.options:c;a&&a.render&&(k.render=a.render,k.staticRenderFns=a.staticRenderFns,k._compiled=!0,e&&(k.functional=!0)),d&&(k._scopeId=d);var l;if(f?(l=function(a){a=a||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext,a||"undefined"==typeof __VUE_SSR_CONTEXT__||(a=__VUE_SSR_CONTEXT__),b&&b.call(this,i(a)),a&&a._registeredComponents&&a._registeredComponents.add(f)},k._ssrRegister=l):b&&(l=g?function(){b.call(this,j(this.$root.$options.shadowRoot))}:function(a){b.call(this,h(a))}),l)if(k.functional){var m=k.render;k.render=function(a,b){return l.call(b),m(a,b)}}else{var n=k.beforeCreate;k.beforeCreate=n?[].concat(n,l):[l]}return c},i="undefined"!=typeof navigator&&/msie [6-9]\\b/.test(navigator.userAgent.toLowerCase()),j=document.head||document.getElementsByTagName("head")[0],k={},l=function(){return function(a,b){return d(a,b)}};var m=function(){var a=this,b=a.$createElement,c=a._self._c||b;return c("div",{directives:[{name:"context-menu",rawName:"v-context-menu",value:null,expression:"null"}],staticClass:"context-menu-overlay",class:{root:a.isRoot,nested:!a.isRoot},style:{zIndex:a.zIndex},on:{mousedown:function(b){return a.close(b)}}},[a._t("default")],2)};m._withStripped=!0;var n=h({render:m,staticRenderFns:[]},function(a){a&&a("data-v-a0a61860_0",{source:"\n.context-menu-overlay[data-v-a0a61860] {\n    position: fixed;\n    top: 0;\n    left: 0;\n    display: block;\n    width: 100%;\n    height: 100%;\n    overflow: hidden;\n}\n.nested[data-v-a0a61860] {\n    pointer-events: none;\n}\n",map:{version:3,sources:["/home/matt/projects/vue-custom-context-menu/src/components/ContextMenuOverlay.vue"],names:[],mappings:";AAsDA;IACA,eAAA;IACA,MAAA;IACA,OAAA;IACA,cAAA;IACA,WAAA;IACA,YAAA;IACA,gBAAA;AACA;AAEA;IACA,oBAAA;AACA",file:"ContextMenuOverlay.vue",sourcesContent:["<template>\n<div\n    class=\"context-menu-overlay\"\n    :class=\"{ root: isRoot, nested: !isRoot }\"\n    :style=\"{ zIndex }\"\n\n    @mousedown=\"close($event)\"\n    v-context-menu=\"null\"\n>\n    <slot></slot>\n</div>\n</template>\n\n<script>\nexport default {\n    props: {\n        isRoot: {\n            type: Boolean,\n            required: true\n        },\n\n        zIndex: {\n            type: Number,\n            required: true\n        },\n\n        penetrable: {\n            type: Boolean,\n            required: true\n        }\n    },\n\n    methods: {\n        close(event) {\n            // the next line doesn't allow to close the context menu if the native one was requested\n            if (event.which === 3 && event.altKey) return;\n\n            // if the overlay is penetrable then a new context menu will be opened because the mousedown event triggers first\n            // else the overlay won't yet be closed when the contextmenu event takes place hence no other context menus will open\n            if (this.penetrable) {\n                this.$emit(\"close\");\n            } else {\n                event.stopPropagation();\n\n                setTimeout(() => {\n                    this.$emit(\"close\");\n                }, 0);\n            }\n        }\n    }\n}\n</script>\n\n<style scoped>\n.context-menu-overlay {\n    position: fixed;\n    top: 0;\n    left: 0;\n    display: block;\n    width: 100%;\n    height: 100%;\n    overflow: hidden;\n}\n\n.nested {\n    pointer-events: none;\n}\n</style>\n"]},media:void 0})},g,"data-v-a0a61860",!1,void 0,l,void 0),o={components:{ContextMenuOverlay:n},props:{penetrable:{type:Boolean,default:!1},shift:{type:String,default:"x",validator:function(a){return["fit","x","y","both"].includes(a)}},delay:{type:Number,default:500,validator:function(a){return 0<a}}},computed:{root:{cache:!1,get:function(){var a=this;return this.isRoot?this:function(){for(var b,c=a;c;)b=c,c=c.parent;return b}()}},overlayElement:{cache:!1,get:function(){return this.$refs.overlay.$el}},wrapperElement:{cache:!1,get:function(){return this.$refs.wrapper}}},data:function(){return{show:!1,event:void 0,caller:void 0,isRoot:!0,zIndex:1e5,style:{left:0,top:0,height:"auto"},parent:null,sub:null,openTimer:null,closeTimer:null}},methods:{abstractOpen:function(a,b,c){(!c||c.show)&&(this.show||(this.event=a,this.caller=b,c&&(this.parent=c,this.parent.sub=this,this.isRoot=!1,this.zIndex=c.zIndex+1),this.show=!0,this.transpose(),this.isRoot&&(document.documentElement.style.overflow="hidden",document.addEventListener("keydown",this.closeOnEscKey)),this.openTimer=null,this.$emit("opened",this)))},immediateOpen:function(a,b,c){this.cancelDelayedOpen(),this.abstractOpen(a,b,c)},delayedOpen:function(a,b,c){var d=this;this.cancelDelayedOpen(),this.openTimer=setTimeout(function(){d.abstractOpen(a,b,c)},c.delay)},cancelDelayedOpen:function(){this.openTimer&&(clearTimeout(this.openTimer),this.openTimer=null)},abstractClose:function(){this.show&&(this.parent&&(this.parent.sub=null),this.sub&&(this.sub.immediateClose(),this.sub=null),this.isRoot&&(document.documentElement.style.overflow="",document.removeEventListener("keydown",this.closeOnEscKey)),this.show=!1,this.style.height="auto",this.zIndex=1e5,this.closeTimer=null,this.$emit("closed",this))},immediateClose:function(){this.cancelDelayedClose(),this.abstractClose()},delayedClose:function(){var a=this;this.cancelDelayedClose(),this.closeTimer=setTimeout(function(){a.abstractClose()},this.parent.delay)},cancelDelayedClose:function(){this.closeTimer&&(clearTimeout(this.closeTimer),this.closeTimer=null)},closeOnEscKey:function(a){if(27===a.keyCode){for(var b=this;b.sub;)b=b.sub;b.immediateClose()}},preventCollapsing:function(){for(var a=this;a;)a.cancelDelayedClose(),a=a.parent},transpose:function(){var a=this;this.caller?(this.style.left="".concat(this.caller.getBoundingClientRect().right,"px"),this.style.top="".concat(this.caller.getBoundingClientRect().top,"px")):(this.style.left="".concat(this.event.clientX,"px"),this.style.top="".concat(this.event.clientY,"px")),this.style.height="auto",this.$nextTick(function(){var b=a.overlayElement.getBoundingClientRect().width,c=a.overlayElement.getBoundingClientRect().height,d=a.wrapperElement.getBoundingClientRect().width,e=a.wrapperElement.getBoundingClientRect().height,f=a.wrapperElement.getBoundingClientRect().right,g=a.wrapperElement.getBoundingClientRect().bottom;f>b&&("x"===a.shift||"both"===a.shift?a.caller?a.style.left="".concat(a.caller.getBoundingClientRect().left-d,"px"):a.style.left="".concat(parseFloat(a.style.left)-d,"px"):a.style.left="".concat(b-d,"px")),g>c&&("y"===a.shift||"both"===a.shift?a.caller?a.style.top="".concat(a.caller.getBoundingClientRect().bottom-e,"px"):a.style.top="".concat(parseFloat(a.style.top)-e,"px"):a.style.top="".concat(c-e,"px")),0>parseFloat(a.style.top)&&(a.style.top="0px",e>c&&(a.style.height="".concat(c,"px")))})}}};var p=function(){var a=this,b=a.$createElement,c=a._self._c||b;return a.show?c("context-menu-overlay",{ref:"overlay",attrs:{"is-root":a.isRoot,"z-index":a.zIndex,penetrable:a.penetrable},on:{close:a.immediateClose}},[c("div",{ref:"wrapper",staticClass:"context-menu-wrapper",class:{root:a.isRoot,nested:!a.isRoot},style:a.style,on:{mouseenter:a.preventCollapsing,mousedown:function(a){a.stopPropagation()}}},[c("div",{staticClass:"context-menu"},[a._t("default")],2)])]):a._e()};p._withStripped=!0;var q=h({render:p,staticRenderFns:[]},function(a){a&&a("data-v-712aa820_0",{source:"\n.context-menu-wrapper[data-v-712aa820] {\n    position: absolute;\n    pointer-events: initial;\n}\n.context-menu[data-v-712aa820] {\n    box-sizing: border-box;\n    height: 100%;\n    overflow: auto;\n}\n",map:{version:3,sources:["/home/matt/projects/vue-custom-context-menu/src/components/ContextMenu.vue"],names:[],mappings:";AAwSA;IACA,kBAAA;IACA,uBAAA;AACA;AAEA;IACA,sBAAA;IACA,YAAA;IACA,cAAA;AACA",file:"ContextMenu.vue",sourcesContent:["<template>\n<context-menu-overlay\n    v-if=\"show\"\n    ref=\"overlay\"\n\n    :is-root=\"isRoot\"\n    :z-index=\"zIndex\"\n    :penetrable=\"penetrable\"\n\n    @close=\"immediateClose\"\n>\n    <div\n        ref=\"wrapper\"\n        class=\"context-menu-wrapper\"\n        :class=\"{ root: isRoot, nested: !isRoot }\"\n        :style=\"style\"\n\n        @mouseenter=\"preventCollapsing\"\n        @mousedown.stop\n    >\n        <div class=\"context-menu\">\n            <slot></slot>\n        </div>\n    </div>\n</context-menu-overlay>\n</template>\n\n<script>\nimport ContextMenuOverlay from \"./ContextMenuOverlay.vue\";\n\nexport default {\n    components: {\n        ContextMenuOverlay\n    },\n\n    props: {\n        penetrable: {\n            type: Boolean,\n            default: false\n        },\n\n        shift: {\n            type: String,\n            default: \"x\",\n            validator: (value) => [\"fit\", \"x\", \"y\", \"both\"].includes(value)\n        },\n\n        delay: {\n            type: Number,\n            default: 500,\n            validator: (value) => value > 0\n        }\n    },\n\n    computed: {\n        root: { // the root context menu instance (the one that is all the nested ones' ancestor)\n            cache: false, // must be recalculated each time because the same context menu may be opened either as a root or as a nested one\n            get() {\n                return this.isRoot\n                    ? this\n                    : (() => {\n                        let parent = this;\n                        while (parent) {\n                            var root = parent;\n                            parent = parent.parent;\n                        }\n\n                        return root;\n                    })();\n            }\n        },\n\n        overlayElement: {\n            cache: false, // no reactive data to rely on -> must be recalculated each time\n            get() {\n                return this.$refs.overlay.$el;\n            }\n        },\n\n        wrapperElement: {\n            cache: false, // no reactive data to rely on -> must be recalculated each time\n            get() {\n                return this.$refs.wrapper;\n            }\n        }\n    },\n\n    data() {\n        return {\n            show: false,\n\n            event: undefined, // set on open; don't reset because is might be used even after the context menu closed\n            caller: undefined, // set on open; don't reset; stores the context menu item that opened this (nested) context menu\n\n            isRoot: true, // the context menu is root if it's not nested\n            zIndex: 100000, // incremented on open so nested context menus always spawn above each other\n\n            style: {\n                left: 0,\n                top: 0,\n                height: \"auto\"\n            },\n\n            parent: null, // only set for nested context menus\n            sub: null, // only set for parents; stores the nested context menu instance\n\n            openTimer: null,\n            closeTimer: null\n        }\n    },\n\n    methods: {\n        // the logics of context menu opening\n        abstractOpen(event, caller, parent) {\n            // don't open a nested context menu if its parent is closed\n            if (parent && !parent.show) return;\n\n            if (!this.show) {\n                this.event = event;\n                this.caller = caller;\n\n                if (parent) {\n                    this.parent = parent;\n                    this.parent.sub = this;\n\n                    this.isRoot = false;\n                    this.zIndex = parent.zIndex + 1;\n                }\n\n                this.show = true;\n                this.transpose();\n\n                if (this.isRoot) {\n                    document.documentElement.style.overflow = \"hidden\";\n                    document.addEventListener(\"keydown\", this.closeOnEscKey);\n                }\n\n                this.openTimer = null;\n                this.$emit(\"opened\", this);\n            }\n        },\n\n        // public; opens the context menu immediately\n        immediateOpen(event, caller, parent) {\n            this.cancelDelayedOpen();\n            this.abstractOpen(event, caller, parent);\n        },\n\n        // public; opens the context menu after some time (defined by the parent's delay prop); is used exclusively to open nested context menus\n        delayedOpen(event, caller, parent) {\n            this.cancelDelayedOpen();\n\n            this.openTimer = setTimeout(() => {\n                this.abstractOpen(event, caller, parent);\n            }, parent.delay);\n        },\n\n        // public; cancels the request to open the context menu\n        cancelDelayedOpen() {\n            if (this.openTimer) {\n                clearTimeout(this.openTimer);\n                this.openTimer = null;\n            }\n        },\n\n        // the logics of context menu closing\n        abstractClose() {\n            if (this.show) {\n                if (this.parent) {\n                    this.parent.sub = null;\n                }\n\n                if (this.sub) {\n                    this.sub.immediateClose();\n                    this.sub = null;\n                }\n\n                if (this.isRoot) {\n                    document.documentElement.style.overflow = \"\";\n                    document.removeEventListener(\"keydown\", this.closeOnEscKey);\n                }\n\n                this.show = false;\n                this.style.height = \"auto\";\n                this.zIndex = 100000;\n\n                this.closeTimer = null;\n                this.$emit(\"closed\", this);\n            }\n        },\n\n        // public; closes the context menu (and its nested ones) immediately\n        immediateClose() {\n            this.cancelDelayedClose();\n            this.abstractClose();\n        },\n\n        // public; closes the context menu (and its nested ones) after some time (defined by the parent's delay prop); is used exclusively to close nested context menus\n        delayedClose() {\n            this.cancelDelayedClose();\n\n            this.closeTimer = setTimeout(() => {\n                this.abstractClose();\n            }, this.parent.delay);\n        },\n\n        // public; cancels the request to close the context menu\n        cancelDelayedClose() {\n            if (this.closeTimer) {\n                clearTimeout(this.closeTimer);\n                this.closeTimer = null;\n            }\n        },\n\n        // event listener callback that closes the most nested context menu among all the opened ones\n        closeOnEscKey(event) {\n            if (event.keyCode === 27) {\n                let nestedMost = this;\n                while (nestedMost.sub) {\n                    nestedMost = nestedMost.sub;\n                }\n\n                nestedMost.immediateClose();\n            }\n        },\n\n        // cancels delayed closing of this context menu and all its parents\n        preventCollapsing() {\n            let parent = this;\n\n            while (parent) {\n                parent.cancelDelayedClose();\n                parent = parent.parent;\n            }\n        },\n\n        // shifts and shrinks (when necessary) the context menu\n        transpose() {\n            if (this.caller) {\n                this.style.left = `${ this.caller.getBoundingClientRect().right }px`;\n                this.style.top = `${ this.caller.getBoundingClientRect().top }px`;\n            } else {\n                this.style.left = `${ this.event.clientX }px`;\n                this.style.top = `${ this.event.clientY }px`;\n            }\n\n            this.style.height = \"auto\";\n\n            this.$nextTick(() => {\n                let viewportWidth = this.overlayElement.getBoundingClientRect().width;\n                let viewportHeight = this.overlayElement.getBoundingClientRect().height;\n\n                let cmWidth = this.wrapperElement.getBoundingClientRect().width;\n                let cmHeight = this.wrapperElement.getBoundingClientRect().height;\n\n                let furthestX = this.wrapperElement.getBoundingClientRect().right;\n                let furthestY = this.wrapperElement.getBoundingClientRect().bottom;\n\n                if (furthestX > viewportWidth) {\n                    if (this.shift === \"x\" || this.shift === \"both\") {\n                        if (this.caller) {\n                            this.style.left = `${ this.caller.getBoundingClientRect().left - cmWidth }px`;\n                        } else {\n                            this.style.left = `${ parseFloat(this.style.left) - cmWidth }px`;\n                        }\n                    } else {\n                        this.style.left = `${ viewportWidth - cmWidth }px`;\n                    }\n                }\n\n                if (furthestY > viewportHeight) {\n                    if (this.shift === \"y\" || this.shift === \"both\") {\n                        if (this.caller) {\n                            this.style.top = `${ this.caller.getBoundingClientRect().bottom - cmHeight }px`;\n                        } else {\n                            this.style.top = `${ parseFloat(this.style.top) - cmHeight }px`;\n                        }\n                    } else {\n                        this.style.top = `${ viewportHeight - cmHeight }px`;\n                    }\n                }\n\n                if (parseFloat(this.style.top) < 0) {\n                    this.style.top = \"0px\";\n\n                    if (cmHeight > viewportHeight) {\n                        this.style.height = `${ viewportHeight }px`;\n                    }\n                }\n            });\n        }\n    }\n}\n</script>\n\n<style scoped>\n.context-menu-wrapper {\n    position: absolute;\n    pointer-events: initial;\n}\n\n.context-menu {\n    box-sizing: border-box;\n    height: 100%;\n    overflow: auto;\n}\n</style>\n"]},media:void 0})},o,"data-v-712aa820",!1,void 0,l,void 0),r={props:{action:{type:Function,default:function(){}},disabled:{type:Boolean,default:!1}},data:function(){return{calls:void 0}},computed:{cm:function(){return this.$parent.$parent},isCaller:function(){return!!this.calls},isDisabled:function(){return null===this.calls||this.disabled}},watch:{isDisabled:function(a){var b=this;!0===a&&this.isCaller&&(this.calls.cancelDelayedOpen(),setTimeout(function(){b.calls.immediateClose()},0))},calls:function(a,b){this.isCaller&&b&&b.cancelDelayedOpen()}},methods:{itemSelected:function(a){this.isDisabled||(this.isCaller?this.cm.sub===this.calls?this.calls.cancelDelayedClose():(this.cm.sub&&this.cm.sub.delayedClose(),this.calls.delayedOpen(a,this.$el,this.cm)):this.cm.sub&&!this.cm.sub.closeTimer&&this.cm.sub.delayedClose())},selectionAborted:function(){this.isDisabled||this.isCaller&&this.calls.cancelDelayedOpen()},itemTriggered:function(a){var b=this;if(!this.isDisabled)if(this.isCaller)this.cm.sub!==this.calls&&(this.cm.sub&&this.cm.sub.immediateClose(),this.calls.immediateOpen(a,this.$el,this.cm));else{if(3===a.which&&a.altKey)return;this.action(this.cm.event.target,this.cm),setTimeout(function(){b.cm.root.immediateClose()},0)}}}};var s=function(){var a=this,b=a.$createElement,c=a._self._c||b;return c("div",{staticClass:"context-menu-item",class:{caller:a.isCaller,disabled:a.isDisabled},on:{mouseenter:a.itemSelected,mouseleave:a.selectionAborted,mousedown:a.itemTriggered}},[a._t("default")],2)};s._withStripped=!0;var t,u=h({render:s,staticRenderFns:[]},void 0,r,void 0,!1,void 0,void 0,void 0),v={install:function(a){a.directive("context-menu",f),a.component("ContextMenu",q),a.component("ContextMenuItem",u)}};return"undefined"==typeof window?"undefined"!=typeof global&&(t=global.Vue):t=window.Vue,t&&t.use(v),v});
